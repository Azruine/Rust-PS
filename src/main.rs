// use std::cmp::Reverse;
// use std::collections::BinaryHeap;
// use std::collections::HashMap;
// use std::io::stdin;
// use std::io::BufRead;

fn main() {
    // let mut lines = stdin().lock().lines();

    // let line = lines.next().unwrap().unwrap();

    // let mut iter = line.split_whitespace();
    // let v: i32 = iter.next().unwrap().parse().unwrap();
    // let e: i32 = iter.next().unwrap().parse().unwrap();

    // let line = lines.next().unwrap().unwrap();
    // let s: i32 = line.trim().parse().unwrap();

    // let mut graph: HashMap<i32, Vec<(i32, i32)>> = HashMap::new();
    // for line in lines {
    //     let line = line.unwrap();
    //     let mut iter = line.split_whitespace();
    //     let u: i32 = iter.next().unwrap().parse().unwrap();
    //     let v: i32 = iter.next().unwrap().parse().unwrap();
    //     let w: i32 = iter.next().unwrap().parse().unwrap();
    //     graph.entry(u - 1).or_default().push((v - 1, w));
    // }

    // let mut pq = BinaryHeap::from([(Reverse(0), s)]);

    // let mut dist: Vec<Option<i32>> = vec![None; v as usize];
    // curDist curPos
    let 문자열: String = String::from("문자열");
    println!("{문자열}");
}
